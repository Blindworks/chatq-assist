{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ChatService = /*#__PURE__*/(() => {\n  class ChatService {\n    constructor(http) {\n      this.http = http;\n      this.apiUrl = 'http://localhost:8080/api/chat';\n    }\n    sendMessage(request) {\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json',\n        'X-Tenant-ID': 'default-tenant'\n      });\n      return this.http.post(this.apiUrl, request, {\n        headers\n      });\n    }\n    sendMessageStreaming(request) {\n      const subject = new Subject();\n      fetch(`${this.apiUrl}/stream`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Tenant-ID': 'default-tenant'\n        },\n        body: JSON.stringify(request)\n      }).then(response => {\n        const reader = response.body?.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n        const readStream = () => {\n          reader?.read().then(({\n            done,\n            value\n          }) => {\n            if (done) {\n              subject.next({\n                type: 'complete'\n              });\n              subject.complete();\n              return;\n            }\n            buffer += decoder.decode(value, {\n              stream: true\n            });\n            const events = buffer.split('\\n\\n');\n            // Keep the last incomplete event in buffer\n            buffer = events.pop() || '';\n            events.forEach(eventText => {\n              if (!eventText.trim()) return;\n              const lines = eventText.split('\\n');\n              let eventType = '';\n              let eventData = '';\n              lines.forEach(line => {\n                if (line.startsWith('event:')) {\n                  eventType = line.substring(6).trim();\n                } else if (line.startsWith('data:')) {\n                  // DON'T trim the data - preserve whitespace for tokens!\n                  eventData = line.substring(5);\n                }\n              });\n              if (eventType && eventData !== '') {\n                if (eventType === 'token') {\n                  // Token data is just a string, not JSON - preserve whitespace!\n                  subject.next({\n                    type: 'token',\n                    token: eventData\n                  });\n                } else if (eventType === 'metadata') {\n                  try {\n                    const metadata = JSON.parse(eventData.trim());\n                    subject.next({\n                      type: 'metadata',\n                      metadata\n                    });\n                  } catch (e) {\n                    console.error('Failed to parse metadata:', e);\n                  }\n                } else if (eventType === 'messageId') {\n                  try {\n                    const data = JSON.parse(eventData.trim());\n                    subject.next({\n                      type: 'messageId',\n                      messageId: data.messageId\n                    });\n                  } catch (e) {\n                    console.error('Failed to parse messageId:', e);\n                  }\n                } else if (eventType === 'message') {\n                  // Fallback message\n                  subject.next({\n                    type: 'token',\n                    token: eventData\n                  });\n                }\n              }\n            });\n            readStream();\n          }).catch(error => {\n            subject.next({\n              type: 'error',\n              error: error.message\n            });\n            subject.error(error);\n          });\n        };\n        readStream();\n      }).catch(error => {\n        subject.next({\n          type: 'error',\n          error: error.message\n        });\n        subject.error(error);\n      });\n      return subject.asObservable();\n    }\n    getHistory(sessionId) {\n      const headers = new HttpHeaders({\n        'X-Tenant-ID': 'default-tenant'\n      });\n      return this.http.get(`${this.apiUrl}/history/${sessionId}`, {\n        headers\n      });\n    }\n    submitFeedback(request) {\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json',\n        'X-Tenant-ID': 'default-tenant'\n      });\n      return this.http.post(`${this.apiUrl}/feedback`, request, {\n        headers\n      });\n    }\n    static {\n      this.ɵfac = function ChatService_Factory(t) {\n        return new (t || ChatService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: ChatService,\n        factory: ChatService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return ChatService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}