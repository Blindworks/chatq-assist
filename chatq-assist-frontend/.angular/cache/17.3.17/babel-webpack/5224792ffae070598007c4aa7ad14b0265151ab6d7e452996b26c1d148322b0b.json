{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class ChatService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = 'http://localhost:8080/api/chat';\n  }\n  sendMessage(request) {\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'X-Tenant-ID': 'default-tenant'\n    });\n    return this.http.post(this.apiUrl, request, {\n      headers\n    });\n  }\n  sendMessageStreaming(request) {\n    const subject = new Subject();\n    const eventSource = new EventSource(`${this.apiUrl}/stream`, {\n      withCredentials: false\n    });\n    // Need to send POST data via fetch first, then listen to SSE\n    fetch(`${this.apiUrl}/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Tenant-ID': 'default-tenant'\n      },\n      body: JSON.stringify(request)\n    }).then(response => {\n      const reader = response.body?.getReader();\n      const decoder = new TextDecoder();\n      const readStream = () => {\n        reader?.read().then(({\n          done,\n          value\n        }) => {\n          if (done) {\n            subject.next({\n              type: 'complete'\n            });\n            subject.complete();\n            return;\n          }\n          const chunk = decoder.decode(value, {\n            stream: true\n          });\n          const lines = chunk.split('\\n\\n');\n          lines.forEach(line => {\n            if (line.startsWith('data:')) {\n              const data = line.substring(5).trim();\n              if (data === '[DONE]') {\n                subject.next({\n                  type: 'complete'\n                });\n                subject.complete();\n                return;\n              }\n              try {\n                const parsed = JSON.parse(data);\n                if (line.includes('event:token')) {\n                  subject.next({\n                    type: 'token',\n                    token: parsed\n                  });\n                } else if (line.includes('event:metadata')) {\n                  subject.next({\n                    type: 'metadata',\n                    metadata: parsed\n                  });\n                }\n              } catch (e) {\n                // Skip non-JSON lines\n              }\n            } else if (line.includes('event:')) {\n              const eventMatch = line.match(/event:(.*)/);\n              const dataMatch = chunk.match(/data:(.*)/s);\n              if (eventMatch && dataMatch) {\n                const eventType = eventMatch[1].trim();\n                const eventData = dataMatch[1].trim();\n                try {\n                  const parsed = JSON.parse(eventData);\n                  if (eventType === 'token') {\n                    subject.next({\n                      type: 'token',\n                      token: parsed\n                    });\n                  } else if (eventType === 'metadata') {\n                    subject.next({\n                      type: 'metadata',\n                      metadata: parsed\n                    });\n                  }\n                } catch (e) {\n                  // Token might be plain string\n                  if (eventType === 'token') {\n                    subject.next({\n                      type: 'token',\n                      token: eventData\n                    });\n                  }\n                }\n              }\n            }\n          });\n          readStream();\n        }).catch(error => {\n          subject.next({\n            type: 'error',\n            error: error.message\n          });\n          subject.error(error);\n        });\n      };\n      readStream();\n    }).catch(error => {\n      subject.next({\n        type: 'error',\n        error: error.message\n      });\n      subject.error(error);\n    });\n    return subject.asObservable();\n  }\n  static {\n    this.ɵfac = function ChatService_Factory(t) {\n      return new (t || ChatService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ChatService,\n      factory: ChatService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpHeaders","Subject","ChatService","constructor","http","apiUrl","sendMessage","request","headers","post","sendMessageStreaming","subject","eventSource","EventSource","withCredentials","fetch","method","body","JSON","stringify","then","response","reader","getReader","decoder","TextDecoder","readStream","read","done","value","next","type","complete","chunk","decode","stream","lines","split","forEach","line","startsWith","data","substring","trim","parsed","parse","includes","token","metadata","e","eventMatch","match","dataMatch","eventType","eventData","catch","error","message","asObservable","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\bened\\IdeaProjects\\ChatQ-Assist\\chatq-assist-frontend\\src\\app\\services\\chat.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Observable, Subject } from 'rxjs';\n\nexport interface ChatRequest {\n  question: string;\n  sessionId?: string;\n  userEmail?: string;\n}\n\nexport interface ChatResponse {\n  sessionId: string;\n  answer: string;\n  confidenceScore: number;\n  sources: SourceReference[];\n  handoffTriggered: boolean;\n  handoffMessage?: string;\n}\n\nexport interface SourceReference {\n  type: string;\n  title: string;\n  url?: string;\n  id: number;\n}\n\nexport interface StreamingChatResponse {\n  type: 'token' | 'metadata' | 'complete' | 'error';\n  token?: string;\n  metadata?: {\n    sessionId: string;\n    confidenceScore: number;\n    sources?: SourceReference[];\n    handoffTriggered: boolean;\n  };\n  error?: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ChatService {\n  private apiUrl = 'http://localhost:8080/api/chat';\n\n  constructor(private http: HttpClient) {}\n\n  sendMessage(request: ChatRequest): Observable<ChatResponse> {\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json',\n      'X-Tenant-ID': 'default-tenant'\n    });\n\n    return this.http.post<ChatResponse>(this.apiUrl, request, { headers });\n  }\n\n  sendMessageStreaming(request: ChatRequest): Observable<StreamingChatResponse> {\n    const subject = new Subject<StreamingChatResponse>();\n\n    const eventSource = new EventSource(\n      `${this.apiUrl}/stream`,\n      {\n        withCredentials: false\n      }\n    );\n\n    // Need to send POST data via fetch first, then listen to SSE\n    fetch(`${this.apiUrl}/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Tenant-ID': 'default-tenant'\n      },\n      body: JSON.stringify(request)\n    }).then(response => {\n      const reader = response.body?.getReader();\n      const decoder = new TextDecoder();\n\n      const readStream = () => {\n        reader?.read().then(({ done, value }) => {\n          if (done) {\n            subject.next({ type: 'complete' });\n            subject.complete();\n            return;\n          }\n\n          const chunk = decoder.decode(value, { stream: true });\n          const lines = chunk.split('\\n\\n');\n\n          lines.forEach(line => {\n            if (line.startsWith('data:')) {\n              const data = line.substring(5).trim();\n              if (data === '[DONE]') {\n                subject.next({ type: 'complete' });\n                subject.complete();\n                return;\n              }\n\n              try {\n                const parsed = JSON.parse(data);\n\n                if (line.includes('event:token')) {\n                  subject.next({ type: 'token', token: parsed });\n                } else if (line.includes('event:metadata')) {\n                  subject.next({ type: 'metadata', metadata: parsed });\n                }\n              } catch (e) {\n                // Skip non-JSON lines\n              }\n            } else if (line.includes('event:')) {\n              const eventMatch = line.match(/event:(.*)/);\n              const dataMatch = chunk.match(/data:(.*)/s);\n\n              if (eventMatch && dataMatch) {\n                const eventType = eventMatch[1].trim();\n                const eventData = dataMatch[1].trim();\n\n                try {\n                  const parsed = JSON.parse(eventData);\n\n                  if (eventType === 'token') {\n                    subject.next({ type: 'token', token: parsed });\n                  } else if (eventType === 'metadata') {\n                    subject.next({ type: 'metadata', metadata: parsed });\n                  }\n                } catch (e) {\n                  // Token might be plain string\n                  if (eventType === 'token') {\n                    subject.next({ type: 'token', token: eventData });\n                  }\n                }\n              }\n            }\n          });\n\n          readStream();\n        }).catch(error => {\n          subject.next({ type: 'error', error: error.message });\n          subject.error(error);\n        });\n      };\n\n      readStream();\n    }).catch(error => {\n      subject.next({ type: 'error', error: error.message });\n      subject.error(error);\n    });\n\n    return subject.asObservable();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}